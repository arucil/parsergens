use lalrpop_util::ParseError;
use super::ast::*;
use super::lex;
use super::UserParseError;
use super::regex;

#[LALR]
grammar<'input>(input: &'input str);

pub Document: Grammar = <decl*>
  => {
    <>.into_iter()
      .filter_map(|x| x)
      .collect()
  };

decl: Option<Spanned<Decl>> = {
  <l:@L> <decl:rule_decl> <r:@L> => Some(Spanned((l, r), Decl::Rule(decl))),
  <l:@L> <decl:start_decl> <r:@L> => Some(Spanned((l, r), Decl::Start(decl))),
  <l:@L> <decl:token_decl> <r:@L> => Some(Spanned((l, r), Decl::Token(decl))),
  <l:@L> <decl:skip_decl> <r:@L> => Some(Spanned((l, r), Decl::Skip(decl))),
};

rule_decl: RuleDecl =
  <name:ident> Assign <alt1:production> <mut alts:(Or <production>)*> Separator
  => {
    alts.insert(0, alt1);
    RuleDecl {
      name,
      alts,
    }
  }; 

production: Spanned<RuleAlt> = {
  <l:@L> <terms:term+> <r:@L> => Spanned((l, r), RuleAlt::Terms(terms)),
  <l:@L> epsilon <r:@L> => Spanned((l, r), RuleAlt::Epsilon),
};

epsilon: () = LParen RParen;

term: Term = {
  ident => Term::Symbol(<>),
  LParen <terms:term+> RParen QuestionMark => Term::Optional(terms),
  LParen <terms:term+> RParen Asterisk => Term::Many(terms),
  LParen <terms:term+> RParen Plus => Term::Many1(terms),
}

start_decl: StartDecl = Percent Start <name:ident> Separator
  => {
    StartDecl {
      name,
    }
  };

token_decl: TokenDecl = Percent Token <name:ident> <pattern:token_pattern>
  => {
    TokenDecl {
      name,
      pattern,
    }
  };

skip_decl: SkipDecl = Percent Skip <pattern:token_pattern>
  => {
    SkipDecl {
      pattern,
    }
  };

token_pattern: TokenPattern = {
  <regex:regex> =>? regex::parse_regex(
    &regex.1[1..regex.1.len() - 1],
    regex.0 .0 + 1
  )
    .map(|x| TokenPattern {
      kind: TokenPatternKind::Regex,
      source: regex,
      regex: x,
    })
    .map_err(|error| ParseError::User {
      error: UserParseError::RegexError(error),
    }),
  <str:string> =>? regex::parse_string_literal(
    &str.1[1..str.1.len() - 1], str.0 .0
  )
    .map(|x| TokenPattern {
      kind: TokenPatternKind::String,
      source: str,
      regex: x,
    })
    .map_err(|error| ParseError::User {
      error: UserParseError::RegexError(error)
    }),
}

spanned<T>: Spanned<String> = <l:@L> <x:T> <r:@L> => Spanned((l, r), x.text.to_owned());

ident = spanned<Ident>;
string = spanned<String>;
regex = spanned<Regex>;

extern {
  type Location = usize;
  type Error = UserParseError;

  enum lex::Token<'input> {
    Start => lex::Token { kind: lex::TokenKind::Start, .. },
    Token => lex::Token { kind: lex::TokenKind::Token, .. },
    Skip => lex::Token { kind: lex::TokenKind::Skip, .. },

    Ident => lex::Token { kind: lex::TokenKind::Ident, .. },
    Regex => lex::Token { kind: lex::TokenKind::Regex, .. },
    String => lex::Token { kind: lex::TokenKind::String, .. },

    Percent => lex::Token { kind: lex::TokenKind::Percent, .. },
    Assign => lex::Token { kind: lex::TokenKind::Assign, .. },
    Or => lex::Token { kind: lex::TokenKind::Or, .. },
    LParen => lex::Token { kind: lex::TokenKind::LParen, .. },
    RParen => lex::Token { kind: lex::TokenKind::RParen, .. },
    Comma => lex::Token { kind: lex::TokenKind::Comma, .. },
    Asterisk => lex::Token { kind: lex::TokenKind::Asterisk, .. },
    QuestionMark => lex::Token { kind: lex::TokenKind::QuestionMark, .. },
    Plus => lex::Token { kind: lex::TokenKind::Plus, .. },

    Enter => lex::Token { kind: lex::TokenKind::Enter, .. },
    Leave => lex::Token { kind: lex::TokenKind::Leave, .. },
    Separator => lex::Token { kind: lex::TokenKind::Separator, .. },
  }
}