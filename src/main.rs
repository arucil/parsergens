use std::env;
use std::process;
use getopts::Options;
use std::fs;
use std::io;
use std::path::Path;
use walkdir::WalkDir;

fn main() {
  let args = env::args().collect::<Vec<_>>();
  let prog = args[0].clone();
  let mut opts = Options::new();
  opts.optopt("t", "type",
    "Type of parser generation algorithm. Defaults to LALR.\n\
      Supported types: LALR, CLR (case insensitive)",
    "TYPE");
  opts.optflag("h", "help", "Print this message");
  opts.optflag("f", "force", "Force update parsers, ignoring modification time");
  opts.optflag("q", "quiet", "Do not show generated parsers");

  let matches = match opts.parse(&args[1..]) {
    Ok(m) => m,
    Err(err) => {
      eprintln!("{}", err);
      process::exit(1);
    }
  };

  if matches.opt_present("h") {
    print_usage(prog, opts);
    return;
  }

  let force = matches.opt_present("f");

  let ty = matches.opt_str("t");
  let path = if matches.free.len() == 1 {
    matches.free[0].clone()
  } else {
    print_usage(prog, opts);
    process::exit(1);
  };

  let ty = parse_type(&prog, ty.as_ref().map(|s| s.as_str()));

  let path = dunce::canonicalize(path).unwrap();

  process_files(&prog, &path, ty, force);
}

fn print_usage(prog: String, opts: Options) {
  let brief = format!("Usage: {} [options] PATH", prog);
  print!("{}", opts.usage(&brief));
}

fn parse_type(prog: &str, ty: Option<&str>) -> lr::ParserKind {
  let ty = ty.unwrap_or("lalr").to_lowercase();
  match ty.as_str() {
    "lalr" => lr::ParserKind::Lalr,
    "clr" | "lr" => lr::ParserKind::Clr,
    _ => {
      eprintln!("{}: unsupported parser type: {}", prog, ty);
      process::exit(1);
    }
  }
}

fn process_files(
  prog: &str,
  path: impl AsRef<Path>,
  ty: lr::ParserKind,
  force: bool,
) {
  let path = path.as_ref();

  for entry in WalkDir::new(path).into_iter().skip(1) {
    let entry = match entry {
      Ok(entry) => entry,
      Err(err) => {
        let err = err.into_io_error().unwrap();
        print_io_error(prog, path, err);
        process::exit(1);
      }
    };
    let path = entry.into_path();

    if path.components().any(|c| c.as_os_str() == ".git") {
      continue;
    }

    let meta = match fs::metadata(&path) {
      Ok(meta) => meta,
      Err(err) => {
        print_io_error(prog, path, err);
        process::exit(1);
      }
    };

    if meta.is_file() {
      process_file(prog, path, meta, ty, force);
    }
  }
}

fn process_file(
  prog: &str,
  path: impl AsRef<Path>,
  meta: fs::Metadata,
  ty: lr::ParserKind,
  force: bool,
) {
  let path = path.as_ref();

  if path.extension().is_none() || path.extension().unwrap() != "pg" {
    return;
  }

  let mut rs_file = path.file_stem().unwrap().to_owned();
  rs_file.push(".rs");

  let rs_path = path.parent().unwrap().join(rs_file);

  let mut update = force;

  match fs::metadata(&rs_path) {
    Ok(rs_meta) => {
      if meta.modified().unwrap() > rs_meta.modified().unwrap() {
        update = true;
      }
    }
    Err(err) => {
      if err.kind() == io::ErrorKind::NotFound {
        update = true;
      } else {
        print_io_error(prog, path, err);
        process::exit(1);
      }
    }
  }

  if update {
    gen_parser(prog, path, rs_path, ty);
  }
}

fn gen_parser(
  prog: &str,
  pg_path: impl AsRef<Path>,
  rs_path: impl AsRef<Path>,
  ty: lr::ParserKind,
) {
  let pg_path = pg_path.as_ref();
  let rs_path = rs_path.as_ref();

  let src = match fs::read_to_string(pg_path) {
    Ok(src) => src,
    Err(err) => {
      print_io_error(prog, pg_path, err);
      process::exit(1);
    }
  };

  let parser = match lr::build(&src, ty) {
    Ok(parser) => parser,
    Err(errors) => {
      eprintln!("error(s) found in {}:", pg_path.display());
      for err in errors {
        let msg = lr::report::report(pg_path, &src, err);
        for line in msg.lines() {
          eprintln!("  {}", line);
        }
      }
      process::exit(1);
    }
  };

  let generated = lr::gen_code(&parser);
  let generated = format!("\
  // This file is auto-generated by parsergens, not meant for manual editing.\n\
  \n\
  {}", generated);

  if let Err(err) = fs::write(rs_path, &generated) {
    print_io_error(prog, rs_path, err);
    process::exit(1);
  }

  println!("Generated {}", rs_path.display());
}

fn print_io_error(
  prog: &str,
  path: impl AsRef<Path>,
  err: io::Error
) {
  if err.kind() == io::ErrorKind::NotFound {
    eprintln!("{}: file not found: {}",
      prog, path.as_ref().display());
  } else {
    eprintln!("{}: cannot access file {}, error: {}",
      prog, path.as_ref().display(), err);
  }
}